<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://byron.github.io/btank/research/">
        <link rel="shortcut icon" href="../img/favicon.ico">

        <title>About Tank - btank</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/prettify-1.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">btank</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Research <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li class="active">
                            <a href="./">About Tank</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../license/">License</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li >
                    <a rel="next" href="..">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../license/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/Byron/btank">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#about-tank">About Tank</a></li>
        
            <li><a href="#coding-and-software-organization">Coding and Software Organization</a></li>
        
            <li><a href="#tank-commandline-tool">tank commandline tool</a></li>
        
            <li><a href="#templates-and-folders-creation">Templates and Folders Creation</a></li>
        
            <li><a href="#configuration-system">Configuration System</a></li>
        
            <li><a href="#application-launcher">Application Launcher</a></li>
        
            <li><a href="#workflow">Workflow</a></li>
        
            <li><a href="#engines">Engines</a></li>
        
    
        <li class="main "><a href="#insights">Insights</a></li>
        
            <li><a href="#configuration-and-structure">Configuration and Structure</a></li>
        
            <li><a href="#how-shotgun-web-integrates-with-tank">How Shotgun Web integrates with Tank</a></li>
        
            <li><a href="#the-tank-command-startup-sequence">The tank command startup sequence</a></li>
        
            <li><a href="#tank-context-and-how-engines-start-up">Tank Context and how engines start up</a></li>
        
    
        <li class="main "><a href="#interesting-for-evaluation">Interesting - for evaluation</a></li>
        
    
        <li class="main "><a href="#problems-and-solutions">Problems and Solutions</a></li>
        
            <li><a href="#tank-as-part-of-an-assembly">Tank as part of an assembly</a></li>
        
            <li><a href="#studio-and-project-configuration">Studio and Project Configuration</a></li>
        
            <li><a href="#process-launching">Process Launching</a></li>
        
            <li><a href="#templates-and-folder-creation">Templates and Folder Creation</a></li>
        
            <li><a href="#automation-using-shotgun-events">Automation using shotgun-events</a></li>
        
    
        <li class="main "><a href="#btank-and-tank">BTank and Tank</a></li>
        
    
        <li class="main "><a href="#goals">Goals</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="about-tank">About Tank</h1>
<h2 id="coding-and-software-organization">Coding and Software Organization</h2>
<ul>
<li>tk-core by now has a good test suite !</li>
<li>Haven't seen tests in any app or hook. Testing is done manually, and in conjunction with the duplicated code portion, will eventually lead to undetected bugs.</li>
<li>TDs can reload code in-app, it's nice for them as they are not used to test-driven workflows anyway.</li>
<li>docs are nicely written and <a href="https://toolkit.shotgunsoftware.com/entries/23783911">good looking</a></li>
<li><strong>sinful</strong>: Main app's bundle logic with GUI, making it impossible to reproduce their logic in non-gui mode. The latter is neat for automation.</li>
<li>Non test-driven development is encouraged by providing means to reload code while the application is running. This is probably what led to tanks major sin, see top of the document.</li>
<li>Probably as some kind of workaround, required frameworks (if provided by tank) can't just be imported, but need a custom method to be called. They also have non-python compatible characters in their names, like dashes ... (maybe there is a way to convert them to their python names procedurally).<ul>
<li>This makes deriving hooks from one another special too - you can inherit from the hook you are overriding, but someone else can't inherit from you as there is exactly one level of overrides for hooks.</li>
<li>There is a special syntax which allows multi-inheritance, which greatly re-invents the wheel. Inside of the hook, it's very abstract what your base actually is, and even worse, can change without the code knowing. Another form of redundancy.</li>
</ul>
</li>
<li>Hooks can access the parent app through <code>self.parent</code>, which doesn't help in isolating them.</li>
<li>Tk-core is special, and typically shared. Can be localized, which makes it a standalone copy based on some other copy.</li>
<li>Even hooks are defined in yaml, which is degenerating what can actually be done in a programming language. When extending implementation, its more powerful to use language facilities (i.e. types, delegate-patterns, events, plugin systems). They are supposed to be lightweight, but calling them is super expensive, even for python.</li>
<li>Docs are separated from the code repositories. This means, they easily get out of sync with what's implemented, as the developer has to break out of the normal dev-environment. What's worse is that contributors can't make fixes while they are reading.</li>
<li>it looks very expensive to use frameworks, as they are instantiated and loaded just for you. Even though it might be good for avoiding shared state and components affecting each other, I doubt it's really what you want.</li>
<li>(plenty of code I would want to override is on module level, which forces me to monkey patch every single function. If it would be a class level method, only the class would need monkey patching, or instantiation. The latter would be the desired way.) - I don't think I will override framework loading.</li>
<li>As they don't have a wrapper, they workaround this with dirty sys.path hacks. This makes their structure and way of working so much more complex ... it's not OK. There is a lot of code dancing around this fact !<ul>
<li>this is also why there is lots of magic involved, and lots of assumptions about the folder structure. That's quite bad, as you will never guess why it's doing what it's doing (i.e. 'config/core/templates.yml' is special and used to find out if the core is 'localized')</li>
</ul>
</li>
<li>The more I dig into the code, the more redundancy I notice. There are 9 rather simmilar usages of the 'install_location.yml', building a path to it in 'config/core'. Argh, it gets worse the more you look ! They get paid by the line of codes they make, now it's clear.</li>
<li>different 'pipeline configurations' allow to do sandboxes/local testing. If configuration is linked up with git, it's actually maintainable.</li>
<li>can be started from existing pipelines, such that tank is clean enough not to do much on import. It relies on a <code>tk</code> singleton.</li>
<li>The code does a lot of error checking, especially when reading external files, which are unreliable by definition.</li>
</ul>
<h2 id="tank-commandline-tool"><code>tank</code> commandline tool</h2>
<ul>
<li>tank command subcommands are well documented online, but non-standard (e.g. no usage). The reason for this is that tank is parsing it's commandline arguments itself ... doing worse than what can be done with standard libraries. It's annoying not to get a list of available commands, but to have to <a href="https://toolkit.shotgunsoftware.com/entries/24024798-Administering-and-Configuring-Sgtk">look them up online</a>.</li>
<li>tank commandline tools are based on a lot of interaction, querying the user for input. This actively discourages their integration into scripts, and kind of misses the target group</li>
<li>Text files created by setup_project are executable for some reason</li>
</ul>
<h2 id="templates-and-folders-creation">Templates and Folders Creation</h2>
<ul>
<li><strong>sinful</strong>: to me it looks like the template system and the 'path schema' in the project configuration are different things. One is used for general paths when doing 'create paths ...' from shotgun or the commandline, the other is used in path templates for apps. This redundancy can make both go out of sync easily !! Really ? Of course they do it to have a simple way to copy skeletons automatically. But what are skeletons worth if they are not customized to the project ? It's a sin, as the path creation system should make sure paths and names are always right !</li>
<li>path template system configuration is redundant, and inflexible (proof). You are forced to repeat yourself. There is a way ('inclusion'), but what's less redundant than a tree ?</li>
<li>path inference needs to know the ‘type’ of path you look at. The 'type' is the template name. This means you can't </li>
<li>capitalization in dict keys [fields] for path template system (used to differentiate shotgun entity types [context fields] from custom template fields manipulated by apps). Capitalization shouldn't be important, but it is as it is used to match shotgun entity names.</li>
<li>app-configuration is one per file. Overrides are done redundantly per environment. It's a general issue though if no central cascading tree is used (like kvstore)</li>
<li>good: versions in yaml have ‘v’ prefix to make sure they become string, not float, even without quoting them. Actually, it's not done like that in real configuration files, so it seems redundant.</li>
<li>They warn the user when launching the toolkit with so far untested versions of the host application.</li>
<li>path template validation. <code>bsemantic</code> does this in test-cases, but something similar must exist to make it failsafe/easy to use. To not be forced to put everything into yaml, the system could collect plugins that support a certain interface, and call their generators to see if a particular context can work.</li>
<li>deferred path creation is a good, as it will create directories only when the asset is actually worked on. My way of doing it would be to respond to particular changes though, so the directory and basesetup is created when the task is assigned or set to in-progress. Nonetheless, I see the point.</li>
<li>template system can be used for paths and strings</li>
<li>multi-root configuration is possible, and easy to configure, but verbose as everything.</li>
<li>It's possible to centralize configuration while maintaining the ability to make overrides by using configuration includes<ul>
<li>it's possible to use information from the context in these paths for substitution (similar to what seems to work in many places where paths are involved)</li>
</ul>
</li>
<li><strong>sinful</strong> Tank is using a <code>path_cache.db</code>, which maps local paths to the entities they represent. This is a huge problem, as it can easily go out of sync with what's actually on the filesystem. When that happens, think start to fail. Besides, sqlite is used on a shared space, which is guaranteed to <a href="http://sqlite.org/faq.html#q5">fail in concurrent situations</a>.</li>
</ul>
<h2 id="configuration-system">Configuration System</h2>
<ul>
<li>Upgrade config files on schema change<ul>
<li>Even though I think there should be viable defaults, this is not always possible. Generally one should refrain from introducing changes that break an application if a piece of information doesn't exist. Instead, the application should deal with it. It's good to have a facility that can handle these updates though.</li>
<li>Upgrading means rewriting, which would probably drop comments ... .</li>
</ul>
</li>
<li>Redundant per context configuration (aka environments) (see what's good as a partial remediation to this issue)<ul>
<li>This seems like a workaround to a 'single-file' configuration system paradigm.</li>
<li>you are forced to repeat yourself when configuring apps (-maintainability, +complexity)</li>
<li>there are ways to centralize the configuration using git, or to make inclusions, which can reduce the impact of this issue. Still it's just not as good as having a base and pulling in overrides.</li>
</ul>
</li>
<li>environment configuration files are non-sparse, which means a lot of text that just says 'default' as value. Whenever someone adds a new attribute/property in the engine/app configuration, your configuration files will not see it anyway, and thus be 'sparse' unintentionally. This leaves you with unnecessarily verbose configuration that I dislike already.</li>
<li>Provided the 'semantic configuration file names' feature for environments is dynamic, configuration selection by context is something <code>bcore</code> doesn't do right now. This runtime feature could be implemented easily though, provided we have context information. Done in the 'pick_environment' hook - the equivalent would be done in a custom Application (for runtime changes) or a delegate for pre-runtime changes. The latter is more powerful as the entire program configuration can be adjusted properly.</li>
<li>yaml-configurable schemas for pretty much everything. bapp could make that possible, after all it's just a KeyValueStoreSchema from settings</li>
<li>very declarative when it comes to what code requires to work, e.g. which environment code expects. In <code>bcore</code>, there is no such thing as code specific to a particular environment will have a package requirement to the needed package, will be a plugin that implements an interface. The latter is abstract.</li>
<li>As required framework versions are specified per application, it's easy to have one application which prevents anything to come up. In <code>bcore</code>, this check is left to the code (and to the one writing configuration files) - but the code will only recognize the version issue when the applications is launched. Chances are that it isn't even called. However, <code>bcore</code> isn't able to determine if packages have incompatible requirements, in terms of the version they need.</li>
<li>Automatic shotgun schema upgrades - engines or apps in need for a particular field will be sure to have it.</li>
<li>at least environment variables can be used to specify hooks, <code>{$EVAR}/path/to/hook.py</code>. That will make customizations so much easier, considering bprocess will be used to set everything up.</li>
<li>there is a 'dict' value type, which allows one level of nesting for values, effectively. But not more.</li>
<li>tank has more meta-data for its schema's than the kvstore. The latter wants it that way, yet <code>bproperties</code> could be used to one day get more meta-data for schema values. After all GUIs will want to have that.</li>
<li>Configuration is handled manually by default, and even though there are tools to help managing it, by default there is not RCS. This is inherently dangerous on sites that have many developers. <code>push_configuration</code> for instance replaces the desired target configuration with the one you are seeing, making a zip backup of the previous configuration files. The docs say nothing how to roll back using one of these, or how to verify that no one else edited them prior to that.</li>
<li>studio level base configuration can be put into git, and then used as base from which to clone when creating new configurations. Interestingly, this doesn't seem to include environments at all, at least not according to the docs. What is it worth without it ? Oh, one more example later and it seems it can do it that way. Good. Well, trying it shows that he can also copy a file path, and doesn't get that this is actually a git repository. Nonetheless, this can be fixed after the fact (by putting the repo) using a path of the form described at <code>tank/deploy/git_descriptor.py:34</code>.<ul>
<li>It's actually exactly the same as what's done with <code>tk-config-default</code> or <code>tk-config-multiroot</code></li>
</ul>
</li>
</ul>
<h2 id="application-launcher">Application Launcher</h2>
<ul>
<li>can only launch packaged programs on OSX, like <em>/Applications/Nuke8.0v4/Nuke8.0v4.app</em>, whereas <em>/Applications/Nuke8.0v4/Nuke8.0v4.app/Nuke8.0v4</em> doesn't work (but works on commandline)</li>
<li>it takes about 5s until the application even starts to load when launched from the shotgun web gui</li>
</ul>
<h2 id="workflow">Workflow</h2>
<ul>
<li>In order to obtain shot folders, one has to perform an action manually. What you want is to set the status of the shot to something indicating it can now be handled, and have the system create the paths for you. However, folder creation is automatically done when launching an application.</li>
<li>It seems by default, new files have no name, so user is free to choose. This needs customization, but might be intended for the default configuration.<ul>
<li>You have to use 'Shotgun Save As ...' in order to land save in right folder </li>
<li>For some reason, it doesn't allow '_-' by default (??)</li>
</ul>
</li>
<li>Context can dynamically change, see 'Work Files App', or 'pick_environment' hook</li>
</ul>
<h2 id="engines">Engines</h2>
<ul>
<li>Not all engines support <code>TANK_FILE_TO_OPEN</code>, they simply don't implement it, but delete the variable from the environment.</li>
</ul>
<h1 id="insights">Insights</h1>
<h2 id="configuration-and-structure">Configuration and Structure</h2>
<p>It looks like tank is literally spitting them everywhere. Generally we differentiate between <code>studio</code>, <code>project</code> and <code>localized</code> configuration types, as well as per-bundle configuration, and configuration within shotgun itself.</p>
<p>Let's define some abstract root paths, which are used when denoting any paths</p>
<ul>
<li><code>BUNDLE</code><ul>
<li>A bundle is anything that tank deals with, like <code>tk-core</code>, <em>engines</em> or <em>apps</em>. Note that hooks are no bundles, but just single python files</li>
</ul>
</li>
<li><code>TANK_STUDIO</code><ul>
<li>points to the studio configuration, usually at /mnt/software/tank/studio</li>
</ul>
</li>
<li><code>PROJECT</code><ul>
<li>points to the project data directory, e.g. at /mnt/projects/myproject</li>
</ul>
</li>
<li><code>TANK_PROJECT</code><ul>
<li>points to the per-project configuration/installation of tank, e.g. PROJECT/etc/tank . Typically, this points to PROJECT/tank, which is also why tank duplicates its folder structure partially.</li>
</ul>
</li>
<li><code>SHOTGUN</code><ul>
<li>Is merely a marker to indicate we are looking at data in the studios shotgun instance</li>
</ul>
</li>
</ul>
<p>Everything written in the following is based on my knowledge so far, obtained through reverse-engineering.</p>
<h3 id="bundle-configuration">BUNDLE Configuration</h3>
<p>A <a href="https://toolkit.shotgunsoftware.com/entries/22275546-How-to-write-Apps#The%20Template%20Starter%20App">bundle</a> is identified exclusively through it's manifest, <code>info.yml</code>. It's well documented, and handled by tank entirely. You won't have to touch it unless you are an app developer.</p>
<p>It's worth nothing though that the <code>tk-core</code> bundle has special wrapper scripts at <code>BUNDLE/setup/root_binaries/tank[.bat]</code> which are copied to the PROJECT configuration whenever a new project is setup. They are called by the shotgun web GUI, see <em>How Shotgun Web integrates with Tank</em>.</p>
<h3 id="tank_studio-configuration-and-installation">TANK_STUDIO Configuration and Installation</h3>
<p>By default, the TANK_STUDIO root only contains basic configuration that will rarely change, and an installation of <code>tk-core</code> (a single version), and all <code>required</code> <em>engines</em> and <em>apps</em>. The term <code>required</code> means that tank will automatically install what's needed based on PROJECT configuration when the first one is initialized. As most people start out with the <code>tk-config-default</code> one, they will end up with about 625MB on disk. The data is quite redundant, so git compresses it down to 150MB. The <em>engines</em> and <em>apps</em> may exist in various versions in parallel, which allows you to switch between them safely.</p>
<p><code>tk-core</code> maintains its own installation, organizing its bundles like so:</p>
<pre class="prettyprint well"><code>TANK_STUDIO/install/BUNDLE_TYPE/SOURCE    /BUNDLE_NAME/VERSION/
TANK_STUDIO/install/engines    /app_store/tk-maya     /v0.4.1
</code></pre>

<p>The core itself is located at <code>TANK_STUDIO/install/core</code>.</p>
<p>Therefore, core doesn't support versions, as it has to serve as an entry point that needs to be known very well. In theory, I believe multi-version cores can be implemented even with the current version, but consistent upgrade paths might be difficult to achieve if people jump between versions.</p>
<p>A fresh installation places the studio configuration into <code>TANK_STUDIO/config/core</code>, which contains the following files</p>
<ul>
<li><code>app_store.yml</code><ul>
<li>Looks to me like a shotgun instance with information about where to download things. I didn't dig into it as it's not relevant for me right now.</li>
</ul>
</li>
<li><code>install_location.yml</code><ul>
<li>Contains three paths, each with an <em>absolute</em> path of the installation directory. The code handling it <em>doesn't</em> resolve environment variables, which makes it difficult to make it location independent.</li>
<li>I will have to dig into the code more and try things before I can tell how it's possible to circumvent these 'hardcoded' paths for more location independence.</li>
</ul>
</li>
<li><code>shotgun.yml</code><ul>
<li>Looks unsurprisingly similar to the <code>app_store.yml</code>, providing login information for the studio's shotgun instance.</li>
</ul>
</li>
<li>`interpreter_[Darwin|Linux|Windows].cfg<ul>
<li>They contain just one line: the path to the system's python interpreter on the respective platform. It's read by the phase 2 tank bootstrapper (<code>tank_cmd[_login].sh</code>) to find the interpreter to use for launching <code>tank_cmd.py</code>. See 'The <code>tank</code> command startup sequence'</li>
</ul>
</li>
</ul>
<h3 id="project-configuration">PROJECT Configuration</h3>
<p>This seems to be a more hard-coded location, as it is always in the PROJECT root, no matter where you install the tank configuration to. It hosts the following files</p>
<ul>
<li><code>PROJECT/tank/cache/path_cache.db</code><ul>
<li>Contains a mapping between the project-relative path on disk and the entity with meta-data. From there, tank knows what to do with the file.</li>
<li>It's heavily used, and really needs to be fast.</li>
<li>Written whenever an asset is touched, each token of a path that corresponds to an Entity is listed there. A shot like 'shots/<sequence>/<shot>' leaves its sequence entity there, as well as its shot entity.</li>
<li><strong>If it gets lost or is corrupted, tank will be rather blind</strong></li>
</ul>
</li>
<li><code>PROJECT/tank/config/tank_configs.yml</code><ul>
<li>Contains the project's TANK configuration locations for all platforms as absolute paths.</li>
<li>It doesn't look like environment variables are resolved when handling the data, which makes it hard to impossible to make it relocatable.</li>
</ul>
</li>
</ul>
<h3 id="tank_project-configuration">TANK_PROJECT Configuration</h3>
<p>This is a big one, as it keeps plenty of interesting caches and configuration files and shows that tank tries really hard to be somewhat pseudo relocatable. Primarily it masks that the actual installation is in the TANK_STUDIO root.</p>
<p>The caches are located at <code>TANK_PROJECT/cache</code></p>
<ul>
<li><code>cache/shotgun_&lt;platform_short&gt;_&lt;entity_type&gt;.txt</code><ul>
<li>A cache created by the shotgun command, and for the phase 1 bootstrapper scripts to be able to quickly return launcher information on a per-platform per-entity-type basis. Their contents is a digest of what was contained in the studio configuration. The latter needs to be interpreted by the python code, which tends to be quite slow compared to bare bash.</li>
<li>The <code>tank[.bat]</code> phase one wrapper will check for these queries and return the cache if possible. Otherwise it hands over to phase 2, which reaches python to do the work just once.</li>
<li>Whenever there is a page-reload, the cache is refreshed, which also ensures configuration changes are picked up quickly. It also means that one of there are plenty of expensive calls while browsing (python is the slow part)</li>
</ul>
</li>
<li><code>BUNDLE_NAME</code><ul>
<li>pretty much a dump for bundles (apps, frameworks, engines) with free-form cache data underneath</li>
<li>commonly used  as icon and image cache, to save expensive lookups from the web. This could also mean the cache goes out of date unless some sort of TTL is implemented.</li>
</ul>
</li>
</ul>
<p>The second largest part is the <code>TANK_PROJECT/install</code> directory, which superficially looks like the <code>TANK_STUDIO/install</code> location. Except for it's all fake to simulate some expected structure for some scripts that should work there and in the actual <code>TANK_STUDIO/install</code> location.</p>
<p>The interesting files are in <code>TANK_PROJECT/install/core</code></p>
<ul>
<li><code>core_[Darwin|Linux|Windows].cfg</code><ul>
<li>A file with just a single line being an absolute path to the <code>TANK_STUDIO</code> location.</li>
<li>Interpreted by the scripts explained below</li>
</ul>
</li>
<li><code>python/[sgtk|tank]/__init__.py</code><ul>
<li>A great example for how marketing decisions force programmers to introduce redundancy and even more complexity: <code>tank</code> was renamed to <code>sgtk</code> when it went from alpha to beta. Using some tricks, old code can still use <code>tank</code> internally, whereas new code can use <code>sgtk</code></li>
<li>a so called <code>proxy wrapper</code> which loads the files mentioned above, and manipulates the <code>sys.path</code> and <strong>TANK_CURRENT_PC</strong> environment variable to call home, the actual implementation at <code>TANK_STUDIO</code>. The latter can then determine where it is coming from using the said environment variable, reading config files and so on.</li>
</ul>
</li>
</ul>
<p>Now we enter the heart of the configuration, <code>TANK_PROJECT/config</code>. It noteworthy that it is a bundle, which means that it can be 'installed' with git and versioned. It's part of the 'evolving configuration' paradigm, and can be replaced by other, possibly pre-made, configurations 'relatively' easily. Those could be <code>tk-config-default</code> or <code>tk-config-multi-root</code>.</p>
<p>The <code>config</code> bundle can be supposedly be used by apps and frameworks to grab icons, hooks and configuration files. However, I believe it's primarily used by <code>tk-core</code> and then given to other bundles through APIs. Didn't dig into that though.</p>
<ul>
<li><code>info.yml</code><ul>
<li>Shows it's a bundle, but I am not sure if it used that way.</li>
</ul>
</li>
<li><code>after_project_create.py</code><ul>
<li>I don't actually know why a hook was dropped there, outside of it's native habitat, the <code>hooks</code> folder.</li>
</ul>
</li>
</ul>
<p>As most of the contents is well described in the official docs, I will focus on the files interesting to the <code>tank</code> startup. Let's look at <code>TANK_PROJECT/config/core</code>. All files not mentioned here are the same as in <code>TANK_STUDIO/config/core</code></p>
<ul>
<li><code>install_location.yml</code><ul>
<li>It's a reflection of the information in the <code>primary</code> pipeline configuration entity of the respective project, containing multi-platform paths to <code>TANK_PROJECT</code></li>
<li>It's a somewhat redundant copy of <code>PROJECT/tank/config/tank_configs.yml</code>, and environment variables in paths are not resolved when it's handled.</li>
</ul>
</li>
<li><code>pipeline_configuration.yml</code><ul>
<li>It's the reverse of the <code>install_location.yml</code>, containing the entity information for querying the PipelineConfiguration entity which in turn contains path information similar to <code>install_location.yml</code>, next to other web gui related stuff.</li>
</ul>
</li>
<li><code>roots.yml</code><ul>
<li>Contains multi-platform paths similar to the SHOTGUN information regarding it's primary <strong>Local File Storage</strong> .</li>
<li>It's keyed to that multiple <strong>Local File Storage</strong> roots can be cached there, and I believe it's used when resolving templates and when using the path schema for creating folders and skeletons.</li>
</ul>
</li>
</ul>
<h3 id="shotgun-configuration">SHOTGUN Configuration</h3>
<p>The <code>PipelineConfiguration</code> entity contains the project's <code>TANK_PROJECT</code> root paths for all platforms, and allows the shotgun web gui to find the <code>tank</code> executable at <code>TANK_PROJECT/tank</code> to obtain tank related information and work with the file system.</p>
<p>In conjunction with the shotgun plugin (formerly java plugin), this allows shotgun to execute arbitrary files and obtain their standard output, standard error and exit code. This is used to populate right-click menues with configured launchers, and to execute tank commands on the user's machine.</p>
<h2 id="how-shotgun-web-integrates-with-tank">How Shotgun Web integrates with Tank</h2>
<p>The shotgun plugin is able to execute files, and that's it. This capability is used to launch the project-specific tank executable. This one is known thanks to the 'primary' (or whichever) PipelineConfiguration entity associated with the project.</p>
<p>This command is a boostrapper which loads tk-core and uses it for evaluating the configuration, returning values interpreted by java script (?).</p>
<p>Those are typical invocation the gui frontend does, including their return values</p>
<pre class="prettyprint well"><code class="bash">${config}/tank shotgun_cache_actions Asset shotgun_mac_asset.txt
# writes the specified text file - apparently configuration loading is slow enough to require
# a speed up. This is something to think about when bringing in own tools,  
# who should be fast too
${config}/tank shotgun_get_actions shotgun_mac_asset.txt shotgun_asset.yml
# Runs in 0.017 seconds, bash only
&gt; launch_nuke$Launch Nuke$$False
&gt; show_in_filesystem$Show in File System$$True
&gt; launch_photoshop$Launch Photoshop$$False
&gt; preview_folders$Preview Create Folders$$True
&gt; create_folders$Create Folders$$True
&gt; launch_screeningroom$Show in Screening Room$$False
&gt; launch_maya$Launch Maya$$False
${config}/tank shotgun_run_action launch_nuke Task 2517
# launches nuke, after redirecting the call to tank_cmd_login.sh, which is similar to tank_cmd.sh
# but uses a different shebang. Copy-past at its finest.
# In the end it launches tank like so (after setting the PYTHONPATH accordingly)
# /System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python [...]/dependencies/lib/tank/studio/install/core/scripts/tank_cmd.py [...]/dependencies/lib/tank/studio shotgun_run_action launch_maya Task 2517 --pc=[...]/PROJECT/etc/tank
# It is refusing to use the CWD for anything (as a native context for instance)
# This command takes exactly 7s due to various shotgun queries, until it finally launches nuke
</code></pre>

<p>Conclusions are</p>
<ul>
<li>the project tank executable needs to be as fast as possible<ul>
<li>It blocks the web-frontend, which waits with drawing until command returns.</li>
<li>If our own wrapper can easily be integrated by adjusting the studio installation's tank command at <em>install/core/scripts/tank_cmd.py</em></li>
</ul>
</li>
<li>The python command itself is extremely slow at launching applications, probably due to various shotgun queries it does in the process.<ul>
<li>It takes quite unacceptable 7s in my tests to commence launching any application.<ul>
<li>tank itself is initialized after 0.22s (<code>tk = tank.tank_from_path(pipeline_config_root)</code>)</li>
<li>a context is available (from entity) after 0.8s (<code>ctx = tk.context_from_entity(entity_type, entity_ids[0])</code>)</li>
<li>an engine is available after 2.7s (<code>e = engine.start_shotgun_engine(tk, entity_type, ctx)</code>)</li>
<li>executes the actual command, which returns after a whopping 7s (<code>e.execute_command(action_name)</code>)</li>
</ul>
</li>
</ul>
</li>
<li>On the setup I work with (sluggish smb-share, mounted on OSX), the wrapper takes 3s to launch anything, which brings overall application startup time to 10s<ul>
<li>However, I believe that the information that ends up in the application is nearly entirely known, which makes filling out the data easy. Combined with an sql read cache, startup can be done in 3.5s or less, with the bcore in charge of course.</li>
</ul>
</li>
</ul>
<h2 id="the-tank-command-startup-sequence">The <code>tank</code> command startup sequence</h2>
<p>As called by the web gui, or from the commandline</p>
<ul>
<li>scripts located in <code>STUDIO/install/core/[scripts|setup]</code></li>
<li>call sequence: <code>TANK_PROJECT/tank[.bat]</code> -&gt; <code>TANK_STUDIO/install/core/scripts/tank_cmd[.bat|_login.sh|.sh]</code> -&gt; <code>TANK_STUDIO/install/core/scripts/tank_cmd.py</code></li>
</ul>
<p>Note that the TANK_STUDIO/tank startup sequence is similar, but determines by <em>the presence or absence of files</em> what kind of installation it is. For example, the presence of the <code>TANK_STUDIO/config/core/templates.yml</code> indicates a project installation, and maybe even that it is localized.</p>
<h2 id="tank-context-and-how-engines-start-up">Tank Context and how engines start up</h2>
<p>In order to bring contextual information to the application, tank can use various ways. Generally, it can do it by path, and by entity.</p>
<p>When launching something from the built-in launchers, the context is set using a pickled dict, containing entity data.</p>
<h3 id="environment-variables">Environment Variables</h3>
<ul>
<li>tk-core is their entry point and must be in the PYTHONPATH, e.g. '[...]/studio/install/core/python'</li>
<li><code>TANK_CURRENT_PC</code><ul>
<li>'/Volumes/raid_V/pipelinetest2014/etc/tank'</li>
</ul>
</li>
<li><code>TANK_CONTEXT</code><ul>
<li>pickle of <code>{ '_pc_path': '[...]/PROJECT/etc/tank',
     'additional_entities': [],
     'entity': {'id': 887, 'name': 'bob', 'type': 'Asset'},
     'project': {'id': 638, 'name': 'PROJECT', 'type': 'Project'},
     'step': None,
     'task': None,
     'user': None}</code>        </li>
</ul>
</li>
<li><code>TANK_ENGINE</code>, like 'tk-maya' . The latter is only important for bootstrapping, of course this can be done by an own facility as well. In the end, you </li>
<li><code>TANK_FILE_TO_OPEN</code> - a file that should be opened right away. Warning: depends on the engine's implementation, maya deferres for instance, which will be troublesome in batch mode. But who needs batch mode ;).</li>
</ul>
<h1 id="interesting-for-evaluation">Interesting - for evaluation</h1>
<ul>
<li>Direct and deferred path creation (once in shotgun, once at app start ??)</li>
<li>path inference (obtain fields from path) if template is known</li>
<li>context keeps asset association/shotgun data link</li>
<li>department/process related app configurations are determined as such, whereas <code>bcore</code> uses different wrapper configurations (which allow to do more, effectively, see package.include). It’s called <em>environment</em></li>
<li>core-&gt; engines-&gt; apps -&gt; hooks<ul>
<li>engines are application specific, and seem to be brought up by core</li>
<li>apps are engine plugins, hooks are app plugins</li>
<li>frameworks are used by apps or engines</li>
<li>apps can use other apps, which makes them kind of an executable framework.</li>
</ul>
</li>
<li>app location configuration parameter should allow it to be local (but only so if kvstore resolution is used). Their configuration could in fact be coming from a kvstore, schemas will not overlap.</li>
<li>core hooks allow to choose environments, or make fundamental business logic decisions (e.g. <em>PIPELINE_CONFIG/core/hooks/pick_environment.py</em>)</li>
<li>tank does 'app' configuration at runtime (and makes them available), whereas bprocess is doing it before runtime. Both would combine well, so there might be no need to use bprocess for anything app related.</li>
<li>'shotgun_entitytype.yaml' environment file to configure in-browser RMB menus</li>
<li>pipeline configurations are entities in shotgun, created by the API, pointing to the tank location on a per-project basis. This is where sandboxes are setup. They might support environment variables.</li>
<li><code>sg_connection</code> studio hook in config/core allows to return custom connection types ... oh actually it's adjusting the connection settings - crowed too soon.</li>
</ul>
<p><img alt="under construction" src="https://raw.githubusercontent.com/Byron/bcore/master/src/images/wip.png" /></p>
<h1 id="problems-and-solutions">Problems and Solutions</h1>
<p>To aid defining a course of action, it's best to state the problems showing after first evaluation, in order of their perceived gravity.</p>
<p>Solutions should be given in order of their ascending cost - let's try to find cheap solutions for heavy problems.</p>
<h2 id="tank-as-part-of-an-assembly">Tank as part of an assembly</h2>
<p>Tank is meant to be a standalone, and as self-contained as possible. Yet it should be port of an existing software repository and integrate with it. It's auto-update features and self-managing nature must be well understood to determine a good place and way of handling it.</p>
<h3 id="solutions">Solutions</h3>
<ol>
<li>Treat tank as self-managed unit and integrate it as a whole<ul>
<li>All tank features for BUNDLE management are preserved, pulling on those that are required by a particular project configuration.The TANK_STUDIO location is tracked as a whole.</li>
<li><code>tk-core</code> may exist only in one version for the entire studio, which may be a risk if not handled correctly.</li>
<li>requires no additional or special treatment, except for a few git commands.</li>
</ul>
</li>
<li>As 1., but track multiple <code>tk-core</code> installations<ul>
<li>requires a tight bprocess override to work, as tk-core must be put in the path accordingly.</li>
<li>possibly requires dynamic adjustment of configuration files tank expects to read to work</li>
<li>Allows to choose any tank core version per project, and keeps them available forever in exactly that state.<ul>
<li>This can also be achieved by localizing tank to the project once it's done</li>
</ul>
</li>
<li>requires to maintain and possibly update apps in multiple tank installations</li>
</ul>
</li>
<li>Track tk-core and each BUNDLE as component in an assembly<ul>
<li>makes all tank management features unusable, and probably requires overrides to make it still find it's BUNDLEs</li>
</ul>
</li>
</ol>
<h2 id="studio-and-project-configuration">Studio and Project Configuration</h2>
<p>The studio's configuration should be able to evolve from project to project, and should aid in maintaining and keeping all btank customizations. Fortunately, this is standard-fare, and tank uses git to maintain its standard configuration as a BUNDLE as well.</p>
<p>Project configurations must be derived from the studio configuration, and should be placed right where the project is for consistency, and accessibility. The latter is a somewhat arbitrary choice, but one I prefer for companies that don't have a strong technical background with trained personnel.</p>
<h3 id="solutions_1">Solutions</h3>
<ol>
<li>Maintain own configuration BUNDLE and use it when setting up new projects<ul>
<li>fits perfectly into tanks design, and aligns with the intended use.</li>
<li>proven technique, used by tank itself</li>
<li>each project clone of the studio configuration is tracked and can be migrated back into the studio configuration using git in any way you can imaging</li>
<li>it's safe, and even though its most likely world-writable on the project share, git will always be able to show changes and handle them responsibly.</li>
</ul>
</li>
</ol>
<p>It makes no sense to think of anything else here, as it would be hacky and have more downsides.</p>
<h2 id="process-launching">Process Launching</h2>
<p>Tank's implementation is minimal and allows only for setting arguments and environment variables of the process in question. In practice, there is much more to it, such as:</p>
<ul>
<li>configure extensions and versions thereof to be used in the host applications, along with their dependencies, recursively</li>
<li>Handle GUI launches differently from those in a high performance computing environment</li>
</ul>
<h3 id="solutions_2">Solutions</h3>
<ol>
<li>Just specify the bprocess wrapper as program to be launched<ul>
<li>Add's 3s on an smb share, on top of the 7s tank needs to do anything</li>
<li>simple</li>
<li>relocation not possible, as environment variables <a href="https://github.com/shotgunsoftware/tk-multi-launchapp/blob/master/app.py#L194">aren't resolved</a> in the path. Therefore, an absolute paths will have to be specified.</li>
</ul>
</li>
<li>Adjust phase 2 bootstrapper to launch bprocess wrapper for tank itself<ul>
<li>it's possible to create an 'evolutionary' configuration and adjust the <code>after_project_create.py</code> callback (erm, hook), which has enough information to post-process the phase 1 or phase 2 bootstrappers. This would fit well, as tank supports choosing any git-controlled configuration - <code>btank</code> could just provide it's own.</li>
<li>Full control over environment variables and the tank startup process, which would allow to intercept launch requests entirely and would allow to speed up launching considerable. This is because I think the information tank wants within the host application can easily be obtained under 0.5s, which adds to the 3s the bprocess wrapper needs on a slow SMB share.</li>
<li>Tank would become (more) relocatable, as we control the contents of args (<code>--pc=PATH</code>) and environment variables (<code>TANK_CURRENT_PC</code>). However, it's unclear to what extend the contents of the various other path containing files are affecting it. For some reason I am optimistic about this though.</li>
</ul>
</li>
</ol>
<h2 id="templates-and-folder-creation">Templates and Folder Creation</h2>
<p>Tank comes with a system that requires to specify rules in a very verbose and repetitive fashion. There are two systems to maintain, the template system for paths and names, as well as the folder creation system (schema). They are likely to go out of sync at some point, facilitating undefined behavior.</p>
<h3 id="solutions_3">Solutions</h3>
<ol>
<li>Use bsemantic-style grammar, and build the folder schema and templates.yml from that<ul>
<li>one file for specifying everything (either yaml or .py, depending on the desired declaration language). It's really just a more concise description language, without actually using features of bsemantic.</li>
<li>Support for tank features bsemantic doesn't have, as arbitrary meta-data can be inserted for use in the generated schema/templates.yml.</li>
<li>needs a custom commandline tool and library to implement the transformation, and tank support to figure out which templates actually need to be define in the end. It needs to verify the generated configuration is sufficient.</li>
<li>tank is guaranteed to work with it, once verified.</li>
</ul>
</li>
<li>Use bsemantic to specify grammar, and enforce it's use at runtime<ul>
<li>requires to either change tank code, or heavily monkey-patch it.</li>
<li>depending on the amount of required changes, these are likely to break when tk-core changes, or fail subtly which is hard to debug.</li>
</ul>
</li>
</ol>
<h2 id="automation-using-shotgun-events">Automation using shotgun-events</h2>
<p>TODO: </p>
<h1 id="btank-and-tank">BTank and Tank</h1>
<ul>
<li><code>TODO</code>: write about the setup I am building and why, and how it's done. This could move into the readme, possibly. Write note about studio level configuration, and how it works.</li>
</ul>
<h1 id="goals">Goals</h1>
<ul>
<li>Install it within the standard dependencies assembly, initially there might be no way around the redundant configuration issue. After all, tank must be able to find its manifest files.</li>
<li>separate studio configuration from installation location, maybe just using symlinks</li>
<li>make it use bprocess when starting applications, especially the shotgun plugin to get browser support</li>
<li>Make it use kvstore (if configuration turns out to be too redundant, especially with paths)</li>
<li>
<p>Make it use bsemantic</p>
</li>
<li>
<p>use own sg connection implementation (from bshotgun)</p>
</li>
</ul>
</div>
        </div>

        

        <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/prettify-1.0.min.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>